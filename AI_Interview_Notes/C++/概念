1、socket的基本操作
	服务端
		socket()
		bind()
		listen()
		accept()
		阻塞，直到有客户端连接：connect()
		read()
		write()
		close()

	客服端
		socket()
		bind()
		connect()
		write()
		read()
		close()
		
2、C++特性
	封装：实现代码模块化，封装成类
	继承：实现代码扩展，子类继承父类
	多态性：静态和动态多态性
		静态在编译时期进行，通过函数重载和模板来实现；
		动态多态性在运行时期进行，通过虚函数（虚基类成员函数+虚基类析构函数）+继承来实现。
			1、基类中必须有虚函数，在派生类中必须重写虚函数。重写了虚函数的才能算作是体现了C++多态性。
			2、通过基类指针指向或引用子类的对象，并来调用子类的虚函数。（）通过基类指针或引用的方式调用子类虚函数。
			
	什么是多态呢？ 
	这种由于派生类重写基类方法，然后用基类指针或引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。
	重载:函数名相同，其他不同
	重写：函数名，还回类型，参数个数，参数类型相同，基类中必须有虚函数
	虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。
	纯虚函数 虚函数 = 0，函数没有主体。纯虚函数不能实例化，只是用来给子类提供便利的；
	虚析构函数作用
	析构函数没有声明成虚函数的时候，delete的时候就会直接调用Base类的析构函数而忘掉派生类的析构函数，这样就会造成内存泄漏的问题。
	虚析构函数是为了避免内存泄露，而且是当子类中会有指针成员变量时才会使用得到的。
	也就说虚析构函数使得在删除指向子类对象的基类指针时可以调用子类的析构函数达到释放子类中堆内存的目的，而防止内存泄露的。
	
3、指针与引用区别
	引用必须进行初始化，不能为空，初始化后不可改变
	指针初始化可以在任何时候，可以为空，只可以改变
	从内存分配上看，程序为指针变量分配内存区域，而不为引用分配内存区域，因为引用声明时必须初始化，从而指向一个已经存在的对象。

4、程序崩溃的常见原因
	内存越界，具体的代码形式可为数组下标越界和指针移动越界。
	当指针为空指针或者是野指针时，你再使用它程序就会立马崩溃。而出现空指针或者野指针一般都是下面这几种操作导致的：
		1、指针未赋值
		2、free/delete释放了该对象
		3、不恰当的指针强制类型转换
		
5、delete、 delete[]
	delete p1 在回收空间的过程中，只有 p1[0] 这个对象调用了析构函数，其它对象如 p1[1]、p1[2] 等都没有调用自身的析构函数，这就是问题的症结所在。
	如果用 delete[]，则在回收空间之前所有对象都会首先调用自己的析构函数。
	基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是应该可以的；
	但是对于类对象数组，只能用 delete[]。对于 new 的单个对象，只能用 delete 不能用 delete[] 回收空间。
	使用原则就是：new 和 delete、new[] 和 delete[] 对应使用。

6、数组与指针
	数组：数组是用于储存多个相同类型数据的集合。
	指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。
	
7、SQLite
	SQLite，是一款轻型的数据库，是遵守ACID的关系型数据库管理系统，它包含在一个相对小的C库中。处理速度比MySQL等都快。
	它的设计目标是嵌入式的，而且目前已经在很多嵌入式产品中使用了它，它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了。
	不像常见的客户-服务器范例，SQLite引擎不是个程序与之通信的独立进程，而是连接到程序中成为它的一个主要部分，通信协议是在编程语言内的直接API调用。

8、函数中参数传递的5种方式
	1、值传递：将主调函数的实参值传递给被调函数的形参。
	2、引用传递：被调函数的形参（引用类型）引用主调函数的实参值。
	3、指针传递：被调函数的形参（指针类型）接收主调函数实参的内存地址。
	
9、C/C++编译的程序内存组成，分配方式
	1、 栈区(stack sagment)：由编译器自动分配释放，存放函数的参数的值，局部变量的值等。
	2、堆区(heap sagment) ： 一般由程序员分配释放，若程序员不释放，程序结束时可能由系统回收 。它与数据结构中的堆是两回事。
	3、全局区(静态区)(data sagment)：全局变量和静态变量的存储区域是在一起的，程序结束后由系统释放。数据区的大小由系统限定，一般很大。
	4、文字常量区：常量字符串就是放在这里的， 程序结束后由系统释放。
	5、程序代码区：存放函数体的二进制代码。
	
10、多线程实现方式
	1. 继承Thread类
	2.实现Runnable接口
	3.实现Callable接口
	4.线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。

11、拷贝构造函数，深拷贝浅拷贝
	假设B复制了A，修改A的时候，看B是否发生变化：
	如果B跟着也变了，说明是浅拷贝，拿人手短！（修改堆内存中的同一个值）
	如果B没有改变，说明是深拷贝，自食其力！（修改堆内存中的不同的值）
	浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，
	深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，

12、python调用C++ 与 C++调用python
	python调用C++
		Linux：编译动态链接库test.so; Windows：编译动态链接库test.dll
		1、原生态导出实现，import导入动态链接库（test.so/test.dll）
			1、直接import导入动态链接库（test.so/test.dll）
			2、import ctypes
			   dll = ctypes.cdll.LoadLibrary('./test.so')
			   pdll = ctypes.CDLL('/home/ubuntu/tmp/example.so')
			Python解释器就是用C实现，编译C/C++文件生成动态链接库（test.so/test.dll）,拷到py同一个目录下,import test即可使用。
			如果是cpp源文件，inittest函数必须用extern "C"修饰，把编写的类封装成C函数模式，如果是c源文件，则不需要。
		2、通过boost实现：
			1、通过boost实现，import导入动态链接库（test.so/test.dll）
			2、通过boost实现，导出类，import导入动态链接库（test.so/test.dll）
			3、通过boost实现，导出变参函数，import导入动态链接库（test.so/test.dll）
			4、通过boost实现，导出带Python对象的接口，import导入动态链接库（test.so/test.dll）  
		
	C++调用python 
		加载python环境变量，安装目录及相关lib
		添加头文件 #include <Python.h>
		初始化Python环境 Py_Initialize() 
		添加模块路径（或者说脚本路径）PyRun_SimpleString()
		导入模块PyImport_ImportModule()
		导入函数PyObject_GetAttrString()
		使用函数PyObject_CallObject()
		转换还回类型
		获取结果PyArg_Parse()
		结束释放Py_DECREF()、Py_Finalize()





















