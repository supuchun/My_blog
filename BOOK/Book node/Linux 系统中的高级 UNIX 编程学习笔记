1： GNU Emacs 编辑器 
2： C 程序编译器是 gcc； gcc –c main.c 将 main.c 文件编译成名为 main.o 的对象文件
3：C++ 编 译 器 是 g++； g++ -c reciprocal.cpp 到的是一个名为 reciprocal.o 的对象文件
4:main的两个参数,通常被命名为argc和argv。这两个参数帮助程序获取用户输入
    Linux 系统中,临时文件被存储在 /tmp 文件夹下。当使用临时文件的时候,你需要注意以下的问题:
    · 同一个程序的多个副本可能正在(由同一个用户或不同的用户)并行运行。每个副本都应该使用不同的临时文件以避免冲突。
    · 文件权限的设置应当保证临时文件不会被未被授权的用户修改或替换,从而导致程序行为被改变。
    · 生成的临时文件名应该不可被外界预料;否则,攻击者可能会在程序检测一个文件名是否被占用与实际打开临时文件进行读写之间的间隔进行攻击。
      Linux 提供了 mkstemp 和 tmpfile 两个函数以帮助你解决这些问题,使用 UNIX I/O(open、write 之类)还是标准 C 库的 I/O (fopen、fprintf 之类)
5:将 fork 和 exec 结合使用
    运行一个子程序的最常见办法是先用 fork 创建现有进程的副本,然后在得到的子进程中用 exec 运行新程序。这样在保持原程序继续运行的同时,在子进程中开始运行新的程序。
6：默认情况下,每个进程的 niceness 均为 0。较高的 niceness 值代表了较低的进程优先级;相应的,较低的 niceness 值(负值)表示较高的进程优先级
7:需要注意的是,只有当一个进程以 root 权限运行的时候才能以负的 niceness 值运行其它程序,或降低一个进程的 niceness 值。
8:多数 shell 程序,最后运行的程序的返回值都保存在特殊环境变量$?中。在下面这个例子中 ls 命令被执行了两次,并且每次运行之后会输出返回值。
9:一个简单的清理结束运行的子进程的方法是响应 SIGCHLD 信号,用 wait 清理了进程
10:线程 ID 被表示为pthread_t 类型的值,pthread_t thread_id。函数 pthread_create 负责创建新线程.通常来说,除非特殊情况,不应使用线程取消结束一个线程的执行。通常情况下,当需
  要线程退出的情况下通知线程然后等待线程自动退出才是更好的策略。与进程不同,一个程序中的所有线程运行在同一个地址空间中。果一个线程修改了内存中的一个位置(例如,一个全局变量),
  则其它所有线程都会发现这个变化。因此多个线程可以同时操作同一块数据而不依赖进程间通信技术.
11:通过抛出一个特别设计的异常,然后在顶层的栈框架内再调用 pthread_exit 退出线程。 函数通过抛出一个ThreadExitException异常而不是直接调用pthread_exit来尝试退出线程。
12:互斥体
  GNU/Linux 提供了互斥体(mutex ,全称MUTual EXclusion locks ,互斥锁 )。互斥体是一种特殊的锁:同一时刻只有一个线程可以锁定它。当一个锁被某个线程锁定的时候,
  如果有另外一个线程尝试锁定这个互斥体,则这第二个线程会被阻塞,或者说被置于等待状态。只有当第一个线程释放了对互斥体的锁定,第二个线程才能从阻塞状态恢复运行。
  线程可以通过调用 pthread_mutex_lock 尝试锁定一个互斥体。 调用 pthread_mutex_unlock 将解除对一个互斥体的锁定。
13:让工作线程阻塞以等待新的任务的到达。信号量可以很方便地做到这一点。信号量是一个用于协调多个线程的计数器。
14:Linux 的 clone 系统调用是一个更通用版本的 fork 和 pthread_create。 调用 fork 创建新进程而调用 pthread_create 创建新线程。
15:进程 Vs 线程
  对于一些从并发处理中受益的程序而言,多进程还是多线程可能很难被抉择。这里有一些基本方针可以帮助你判断哪种模型更适合你的程序:
  · 一个程序的所有线程都必须运行同一个执行文件。而一个新进程则可以通过 exec函数运行一个新的执行文件。
  · 由于所有线程共享地址空间和资源,一个错误的线程可能影响所有其它线程。例如,通过未经初始化的指针非法访问内存可能破坏其它线程所使用的内存。
    而一个错误的进程则不会造成这样的破坏因为每个进程都有父进程的地址空间的完整副本。
  · 为新进程复制内存会比创建新线程存在性能方面的损失。不过,由于只有当对内存进行写入操作的时候复制操作才会发生,如果新进程只对内存执行读取操作,性能损失可能微乎其微。
  · 对于需要精细并行控制的程序,线程是更好的选择。例如,如果一个问题可以被分解为许多相对独立的子任务,用线程处理可能更好。进程适合只需要比较粗糙的并行程序。
  · 由于线程之间共享地址空间,共享数据是一件简单的任务。(不过必须倍加小心防范竞争状态的出现)进程之间共享属于要求使用各种IPC机制。这虽然显得更麻烦而笨重,
    但同时避免了许多并行程序错误的出现。
16:访问共享内存区域和访问进程独有的内存区域一样快,并不需要通过系统调用或者其它需要切入内核的过程来完成。在数据被写入之前不允许进程从共享内存中读取信息、
  不允许两个进程同时向同一个共享内存地址写入数据等。再也没有进程需要使用这个共享内存块的时候,必须有一个(且只能是一个)进程负责释放这个被共享的内存页面。
  所有共享内存块的大小都必须是系统页面大小的整数倍。系统页面大小指的是系统中单个内存页面包含的字节数。在 Linux 系统中,内存页面大小是 4KB,不过你仍然应该
  通过调用 getpagesize 获取这个值。进程通过调用 shmget (SHared Memory GET,获取共享内存)来分配一个共享内存块。多个使用共享内存块的进程之间必须协调使用同一个键值
17:要让一个进程获取对一块共享内存的访问,这个进程必须先调用 shmat( SHared Memory Attach,绑定到共享内存)。将 shmget 返回的共享内存标识符 SHMID 传递给这个函数作为第一个参数。
  该函数的第二个参数是一个指针,指向你希望用于映射该共享内存块的进程内存地址;如果你指定 NULL 则 Linux 会自动选择一个合适的地址用于映射。第三个参数是一个标志位.
18:当一个进程不再使用一个共享内存块的时候应通过调用 shmdt (SHared MemoryDeTach,脱离共享内存块)函数与该共享内存块脱离。将由 shmat 函数返回的地址传递给这个函数。
  如果当释放这个内存块的进程是最后一个使用该内存块的进程,则这个内存块将被删除。对 exit 或任何 exec 族函数的调用都会自动使进程脱离共享内存块
19:调用 shmctl ("SHared Memory ConTroL",控制共享内存)函数会返回一个共享内存块的相关信息。同时 shmctl 允许程序修改这些信息。
20:系统调用 semget 和 semctl 负责分配、释放信号量。
21:要将一个普通文件映射到内存空间,应使用 mmap(映射内存,“Memory MAPped”,读作“em-map”)
22:通过调用 msync 强制要求 Linux 将缓存的内容写入文件。 更新一块从 mem_addr 开始的、长度为 mem_length 的共享内存块需要使用如下调用:
    msync (mem_addr, mem_length, MS_SYNC | MS_INVALIDATE);
23:系统调用 mmap 还可以用于除进程间通信之外的其它用途。一个常见的用途就是取代read 和 write 。
24:管道是一个允许单向信息传递的通信设备。从管道“写入端”写入的数据可以从“读取端”读回。管道是一个串行设备;从管道中读取的数据总保持它们被写入时的顺序。
  一般来说,管道通常用于一个进程中两个线程之间的通信,或用于父子进程之间的通信。
  在 shell 中,| 符号用于创建一个管道。 要创建一个管道,请调用 pipe 命令 管道可以自动同步两个进程。
25:创建一个子进程,并将一个管道的一端设置为它的标准输入或输出。利用 dup2 系统调用你可以使一个文件描述符等效于另外一个。例如,下面的命令可以将一个进程的标准输入重定向到文件描述符 
  fd :dup2 (fd, STDIN_FILENO);符号常量 STDIN_FILENO 代表指向标准输入的文件描述符。它的值为 0
26:调用 popen 取代 pipe、fork、dup2 和 execlp 等,一个子进程被创建以执行了sort 命令,。第二个参数,” w” ,指示出这个进程希望对子进程输出信息
  FILE* stream = popen ("sort", "w");
  fprintf (stream, "One fish, two fish.\n");
  return pclose (stream);
27：通过 FIFO 通信,必须有一个程序打开这个 FIFO写入信息,而另一个程序打开这个 FIFO 读取信息。底层 I/O 函数( open、write、read、close 等,列举在附录 B“底层 I/O”中)或
   C 库 I/O 函数( fopen、fprintf、fscanf、fclose 等)均适用于访问 FIFO 。套接字是一个双向通信设备,可用于同一台主机上不同进程之间的通信,也可用于沟通
  位于不同主机的进程。
28:套接字相关的系统调用:
    socket ——创建一个套接字
    close ——销毁一个套接字
    connect ——在两个套接字之间创建连接
    bind ——将一个服务器套接字绑定一个地址
    listen ——设置一个套接字为接受连接状态
    accept ——接受一个连接请求并为新建立的连接创建一个新的套接字
    套接字通常被表示为文件描述符。
  客户端:
    初始化连接的进程,而服务端指的是等待连接的进程。客户端调用 connect 以在本地套接字和第二个参数指明的服务端套接字之间初始化一个连接。
  服务端:
    要想让客户端找到,必须用 bind 将一个地址绑定到服务端套接字。
    将一个地址绑定到一个连接类型的套接字之后,必须通过调用 listen 将这个套接字标识为服务端。
    服务端通过调用 accept 接受一个客户端 connect连接。客户端地址将被写入指针指向的结构中
29:pipe 函数创建了两个文件描述符,分别代表管道的两端。管道有所限制因为文件描述符只能被相关进程使用且经由管道进行的通信是单向的。
    而 socketpair 函数为一台主机上的一对相连接的的套接字创建两个文件描述符。这对文件描述符允许相关进程之间进行双向通信。