1、TCP/IP 是因特网的通信协议，不同的通信协议的大集合。
    在 TCP/IP 内部：
    在 TCP/IP 中包含一系列用于处理数据通信的协议：
    TCP (传输控制协议) - 应用程序之间通信，TCP 使用固定的连接
    UDP (用户数据包协议) - 应用程序之间的简单通信
    IP (网际协议) - 计算机之间的通信，IP 是无连接的状态
    DHCP (动态主机配置协议) - 针对动态寻址
2、TCP/IP
    TCP/IP 意味着 TCP 和 IP 在一起协同工作。
    TCP 负责应用软件（比如您的浏览器）和网络软件之间的通信。
    IP 负责计算机之间的通信。
    TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。 相当于邮寄快递的邮件人和收件人
    IP 负责将包发送至接受者。  相当于快递运输站
    TCP/IP 使用 4 组数字来为计算机编址。每个计算机必须有一个唯一的 4 组数字的地址。
3、域名
    12 个阿拉伯数字很难记忆。使用一个名称更容易。
    用于 TCP/IP 地址的名字被称为域名。w3cschool.cn 就是一个域名。
    当你键入一个像 http://www.w3cschool.cn 这样的域名，域名会被一种 DNS 程序翻译为数字。
    在全世界，数量庞大的 DNS 服务器被连入因特网。DNS 服务器负责将域名翻译为 TCP/IP 地址，同时负责使用新的域名信息更新彼此的系统。
    当一个新的域名连同其 TCP/IP 地址一起注册后，全世界的 DNS 服务器都会对此信息进行更新。
4、OSI七层模型中的物理层、数据链路层和网络层是面向网络通信的低三层，为网络环境中的主机提供点对点通信服务。
    这种通信是直接相连的节点对等实体的通信，它只提供一台机器到另一台机器之间的通信，不会涉及到程序或进程的概念。
    同时点到点通信并不能保证数据传输的可靠性，也不能说明源主机与目的主机之间是哪两个进程在通信。
   端到端通信建立在点到点通信的基础上，它是由一段段的点到点通信信道构成的，是经点到点通信更高一级的通信方式，完成应用程序(进程)之间的通信。
    OSI参考模型中的传输层功能的裨是最终完成端到端的可靠连接。"端"是指用户应用程序的"端口"，端口号标识了应用层中不同的进程，多个进程的数据传递通过不同的端口完成。
5、TCP数据报结构
    Seq：序列号，用来标识数据包；
    Ack：确认号，表示确认；
    SYN：建立新连接的标识；
    FIN：断开连接的标识。
6、三次握手
    1.当客户端请求建立连接后，TCP协议会设置SYN标志位和Seq序号。向服务器端发送数据包，然后进入了SYN-SEND状态。
    2.服务器端收到该数据包后，检测到SYN标志位，同时会设置SYN和ACK标志位，返回数据包给客户端，之后进入SYN-RECV状态。
    3.客户端收到确认包后，会检测ACK标志位的值，如果正确，客户端进入ESTABLISED状态，连接建立成功。
    4.服务器端收确认包后，检测ACK标志位，如果正确，服务器也进入ESTABLISED状态，至此，双向连接建立成功。
经过上面的三次握手，双向连接建立成功之后，就可以开始发送数据了。为了保证数据的准确性，Seq和Ack需要约定好：
    第一次消息发送时Seq为系统生成；
    Ack号 = Seq号 + 传递的字节数 + 1
    而之后发送的Seq号与接收到的Ack数值相同
7、网络通信是两台计算机上的两个进程之间的通信。比如，浏览器进程和新浪服务器上的某个Web服务进程在通信，而QQ进程是和腾讯的某个服务器上的某个进程在通信。
   网络编程对所有开发语言都是一样的，Python也不例外。用Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。
8、互联网上每个计算机的唯一标识就是IP地址，类似123.123.123.123。如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个IP地址，所以，IP地址对应的实际上是计算机的网络接口，通常是网卡。
   IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据通过TCP协议被分割成一小块一小块IP包，然后通过IP包发送出去。路由器就负责决定如何把一个IP包转发出去。TCP协议则是建立在IP协议之上的。
   TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。
   常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。
   一个TCP报文除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。
   一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。
9、客户端 （TCP协议进行Socket编程在Python中）
   创建一个基于TCP连接的Socket，可以这样做：
        # 导入socket库:
        import socket
        # 创建一个socket:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 建立连接:
        s.connect(('www.sina.com.cn', 80))
  创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议。客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。
  新浪网站的IP地址可以用域名www.sina.com.cn自动转换到IP地址，80端口是Web服务的标准端口。
  建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容：
        # 发送数据:
        s.send(b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n')
  发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了：
        # 接收数据:
        buffer = []
        while True:
            # 每次最多接收1k字节:
            d = s.recv(1024)
            if d:
                buffer.append(d)
            else:
                break
        data = b''.join(buffer)
  接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。
  当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了：
        # 关闭连接:
        s.close()
   接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件：
        header, html = data.split(b'\r\n\r\n', 1)
        print(header.decode('utf-8'))
        # 把接收的数据写入文件:
        with open('sina.html', 'wb') as f:
            f.write(html)
  现在，只需要在浏览器中打开这个sina.html文件，就可以看到新浪的首页了。
10、服务器 （TCP协议进行Socket编程在Python中）
     创建一个基于IPv4和TCP协议的Socket：
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    我们要绑定监听的地址和端口，127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。
    端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。请注意，小于1024的端口号必须要有管理员权限才能绑定：
        # 监听端口:
        s.bind(('127.0.0.1', 9999))
    紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量：
        s.listen(5)
        print('Waiting for connection...')
    服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接:
        while True:
            # 接受一个新连接:
            sock, addr = s.accept()
            # 创建新线程来处理TCP连接:
            t = threading.Thread(target=tcplink, args=(sock, addr))
            t.start()
    每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接：
    连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上Hello再发送给客户端。如果客户端发送了exit字符串，就直接关闭连接。
        def tcplink(sock, addr):
            print('Accept new connection from %s:%s...' % addr)
            sock.send(b'Welcome!')
            while True:
                data = sock.recv(1024)
                time.sleep(1)
                if not data or data.decode('utf-8') == 'exit':
                    break
                sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8'))
            sock.close()
            print('Connection from %s:%s closed.' % addr)
    要测试这个服务器程序，我们还需要编写一个客户端程序：
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 建立连接:
        s.connect(('127.0.0.1', 9999))
        # 接收欢迎消息:
        print(s.recv(1024).decode('utf-8'))
        for data in [b'Michael', b'Tracy', b'Sarah']:
            # 发送数据:
            s.send(data)
            print(s.recv(1024).decode('utf-8'))
        s.send(b'exit')
        s.close()
    需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。
    同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。
11、TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。
    使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。
    虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。