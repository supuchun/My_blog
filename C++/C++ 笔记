简要介绍：Linux主要有三个方向：运维、应用、底层，而Linux C/C++ 开发（Linux 服务器开发）这个方向
    目前从事 Linux C/C++ 开发的程序员很多，尤其是像百度、腾讯、阿里这样的大公司，他们的网站流量巨大，业务逻辑复杂，会遇到很多瓶颈，需要开发底层服务来提高程序效率，快速响应用户请求。
    这些公司的 Linux C/C++ 开发属于底层开发（后台服务、算法支持等），而不是应用开发，编写的程序在后台运行，没有界面，不直接面向用户。
    有了数年应用开发的经验，对用户、业务、交互等都非常了解了，转底层开发很容易，也知道应用层的瓶颈在哪里，明白如何在底层做优化。
    那么，这个方向到底适合不适合初学者呢？初学者肯定可以学习，也肯定能找到相关的工作，但是，如果没有应用开发的经验，个人认为只学底层开发是非常枯燥的，因为每天面对一堆理论，早晚吐血。
    初学者可以给自己树立一个目标，做一个类似 QQ 这样的软件出来，它可以有无限的优化空间，比如：
        刚开始只是用 Qt、GTK+、WxWidgets、Fltk 等 GUI 库构建了一个界面，并不能发送和接受信息。
        增加一对一聊天功能，在这个过程中可以学习通信（socket）。
        同时支持多人聊天，每增加一个对话就开启了一个线程，这个过程中可以学习多线程编程。
        提高服务器的性能，让单台服务器同时抗住一万个人聊天，这个时候你可能就需要去优化程序了，就需要关注线程创建、调度的开销，关注通信过程中的缓存。
        增加群聊功能，让服务器可以给多个用户发送消息，这个时候你对通信的理解将更加深入。
        最后呢，你可以将多台服务器联合起来，抗住几十万人甚至上百万人聊天。
    可以自己完成这个项目，也可以组队完成，在这个过程中你将会全方位的学习 Linux C/C++ 编程。
    总之，初学者要让学习过程变得有趣，不要天天研究操作系统、数据结构、算法、内存、线程进程、通信等理论，一定要去实践。
    
1、虚函数的定义要遵循以下重要规则： 
    1.如果虚函数在基类与派生类中出现，仅仅是名字相同，而形式参数不同，或者是返回类型不同，那么即使加上了virtual关键字，也是不会进行滞后联编的。 
    2.只有类的成员函数才能说明为虚函数，因为虚函数仅适合用与有继承关系的类对象，所以普通函数不能说明为虚函数。 
    3.静态成员函数不能是虚函数,因为静态成员函数的特点是不受限制于某个对象。 
    4.内联(inline)函数不能是虚函数，因为内联函数不能在运行中动态确定位置。即使虚函数在类的内部定义定义，但是在编译的时候系统仍然将它看做是非内联的。 
    5.构造函数不能是虚函数，因为构造的时候，对象还是一片位定型的空间，只有构造完成后，对象才是具体类的实例。 
    6.析构函数可以是虚函数,而且通常声名为虚函数。 

2、在C++中,类和结构是只有一个区别的：类的成员默认是private，而结构是public。
   C和C++中都有结构的概念，但是在C语言中结构只有成员变量，而没成员方法，而在C++中结构中，它可以有自己的成员变量和成员函数。但是在C语言中结构的成员是公共的，
   什么想访问它的都可以访问；而在VC++中没有加限定符的类的成员默认是private，而结构是public。

3、将func1和func2封装成一个DLL，能够直接让func3调用

4、静态库和动态库是两种共享程序代码的方式，它们的区别是：静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；动态库在链接阶段没有被复制到程序中，
   而是程序在运行时由系统动态加载到内存中供程序调用。使用动态库的优点是系统只需载入一次动态库，不同的程序可以得到内存中相同的动态库的副本，因此节省了很多内存。
   Windows下动态库为.dll后缀，在linux在为.so后缀。

5、程序的错误大致可以分为三种，分别是语法错误、逻辑错误和运行时错误：
    1) 语法错误在编译和链接阶段就能发现，只有 100% 符合语法规则的代码才能生成可执行程序。语法错误是最容易发现、最容易定位、最容易排除的错误，程序员最不需要担心的就是这种错误。
    2) 逻辑错误是说我们编写的代码思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决。
    3) 运行时错误是指程序在运行期间发生的错误，例如除数为 0、内存分配失败、数组越界、文件不存在等。C++ 异常（Exception）机制就是为解决运行时错误而引入的。
       运行时错误如果放任不管，系统就会执行默认的操作，终止程序运行，也就是我们常说的程序崩溃（Crash）。C++ 提供了异常（Exception）机制，让我们能够捕获运行时错误，给程序一次“起死回生”的机会，
       或者至少告诉用户发生了什么再终止程序。
6、抛出（Throw）--> 检测（Try） --> 捕获（Catch）
    异常必须显式地抛出，才能被检测和捕获到；如果没有显式的抛出，即使有异常也检测不到。
    在 C++ 中，我们使用 throw 关键字来显式地抛出异常，它的用法为：throw exceptionData;

7、模板所支持的类型是宽泛的，没有限制的，我们可以使用任意类型来替换，这种编程方式称为泛型编程（Generic Programming）。
    相应地，可以将参数 T 看做是一个泛型，而将 int、float、string 等看做是一种具体的类型。C++ 模板也是被迫推出的，最直接的动力来源于对数据结构的封装。
    C++ 开发者们希望为线性表、链表、图、树等常见的数据结构都定义一个类，并把它们加入到标准库中，这样以后程序员就不用重复造轮子了，直接拿来使用即可。
    以链表为例，它的每个节点可以用来存储小数、整数、字符串等，也可以用来存储一名学生、教师、司机等，还可以直接存储二进制数据，这些都是可以的，没有任何限制。
    而 C++ 又是强类型的，数据的种类受到了严格的限制，这种矛盾是无法调和的。STL（Standard Template Library，标准模板库）就是 C++ 对数据结构进行封装后的称呼
    
8、在iostream头文件中重载运算符
    “<<”和“>>”本来在C++中是被定义为左位移运算符和右位移运算符的，由于在iostream头文件中对它们进行了重载，使它们能用作标准类型数据的输入和输出运算符。所以，
    在用它们的程序中必须用#include命令把iostream包含到程序中。 #include <iostream> 
    如果在程序中有下面的表达式：
    cout<<"C++";
    实际上相当于：
    cout.operator <<("C++")
    cout和cin并不是C++语言中提供的语句，它们是iostream类的对象，printf和scanf是C语言库函数中的输入输出函数。当向cout流插 人一个endl时，不论缓冲区是否已满，
    都立即输出流中所有数据，然后插入一个换行符， 并刷新流（清空缓冲区）。注意如果插人一个换行符”\n“（如cout<<a<<"\n"），则只输出和换行，而不刷新cout流(但并不是所有编译系统都体现出这一区别）。

9、除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，
    更改一个对象的数据不会影响另外一个对象，这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。

10、C/C++编译的程序占用的内存分为以下几个部分 
    栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈
    堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回 收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表 
    全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另 一块区域。 - 程序结束后由系统释放。
    文字常量区 —常量字符串就是放在这里的， 程序结束后由系统释放
    程序代码区—存放函数体的二进制代码。
        //main.cpp
        int a = 0;   //全局初始化区
        char *p1;   //全局未初始化区
        main()
        {
            int   b;   //栈
            char   s[] = "abc";   //栈
            char   *p2; //栈
            char   *p3 = "123456";   //123456/0在常量区，p3在栈上。
            static   int   c =0；   //全局（静态）初始化区
            p1   = (char *)malloc(10);
            p2   = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。
            strcpy(p1, "123456");   //123456/0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
        }
