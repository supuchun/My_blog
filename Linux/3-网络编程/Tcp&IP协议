  1、TCP/IP 是因特网的通信协议，不同的通信协议的大集合。
    在 TCP/IP 内部：
    在 TCP/IP 中包含一系列用于处理数据通信的协议：
    TCP (传输控制协议) - 应用程序之间通信，TCP 使用固定的连接
    UDP (用户数据包协议) - 应用程序之间的简单通信
    IP (网际协议) - 计算机之间的通信，IP 是无连接的状态
    DHCP (动态主机配置协议) - 针对动态寻址

2、TCP/IP
    TCP/IP 意味着 TCP 和 IP 在一起协同工作。
    TCP 负责应用软件（比如您的浏览器）和网络软件之间的通信。
    IP 负责计算机之间的通信。
    TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。 相当于邮寄快递的邮件人和收件人
    IP 负责将包发送至接受者。  相当于快递运输站
    TCP/IP 使用 4 组数字来为计算机编址。每个计算机必须有一个唯一的 4 组数字的地址。

3、域名
    12 个阿拉伯数字很难记忆。使用一个名称更容易。
    用于 TCP/IP 地址的名字被称为域名。w3cschool.cn 就是一个域名。
    当你键入一个像 http://www.w3cschool.cn 这样的域名，域名会被一种 DNS 程序翻译为数字。
    在全世界，数量庞大的 DNS 服务器被连入因特网。DNS 服务器负责将域名翻译为 TCP/IP 地址，同时负责使用新的域名信息更新彼此的系统。
    当一个新的域名连同其 TCP/IP 地址一起注册后，全世界的 DNS 服务器都会对此信息进行更新。

4、OSI七层模型中的物理层、数据链路层和网络层是面向网络通信的低三层，为网络环境中的主机提供点对点通信服务。
    这种通信是直接相连的节点对等实体的通信，它只提供一台机器到另一台机器之间的通信，不会涉及到程序或进程的概念。
    同时点到点通信并不能保证数据传输的可靠性，也不能说明源主机与目的主机之间是哪两个进程在通信。
   端到端通信建立在点到点通信的基础上，它是由一段段的点到点通信信道构成的，是经点到点通信更高一级的通信方式，完成应用程序(进程)之间的通信。
    OSI参考模型中的传输层功能的裨是最终完成端到端的可靠连接。"端"是指用户应用程序的"端口"，端口号标识了应用层中不同的进程，多个进程的数据传递通过不同的端口完成。

5、TCP数据报结构
    Seq：序列号，用来标识数据包；
    Ack：确认号，表示确认；
    SYN：建立新连接的标识；
    FIN：断开连接的标识。

6、三次握手
    1.当客户端请求建立连接后，TCP协议会设置SYN标志位和Seq序号。向服务器端发送数据包，然后进入了SYN-SEND状态。
    2.服务器端收到该数据包后，检测到SYN标志位，同时会设置SYN和ACK标志位，返回数据包给客户端，之后进入SYN-RECV状态。
    3.客户端收到确认包后，会检测ACK标志位的值，如果正确，客户端进入ESTABLISED状态，连接建立成功。
    4.服务器端收确认包后，检测ACK标志位，如果正确，服务器也进入ESTABLISED状态，至此，双向连接建立成功。
经过上面的三次握手，双向连接建立成功之后，就可以开始发送数据了。为了保证数据的准确性，Seq和Ack需要约定好：
    第一次消息发送时Seq为系统生成；
    Ack号 = Seq号 + 传递的字节数 + 1
    而之后发送的Seq号与接收到的Ack数值相同

7、网络通信是两台计算机上的两个进程之间的通信。比如，浏览器进程和新浪服务器上的某个Web服务进程在通信，而QQ进程是和腾讯的某个服务器上的某个进程在通信。
   网络编程对所有开发语言都是一样的，Python也不例外。用Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。

8、互联网上每个计算机的唯一标识就是IP地址，类似123.123.123.123。如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个IP地址，所以，IP地址对应的实际上是计算机的网络接口，通常是网卡。
   IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据通过TCP协议被分割成一小块一小块IP包，然后通过IP包发送出去。路由器就负责决定如何把一个IP包转发出去。TCP协议则是建立在IP协议之上的。
   TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。
   常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。
   一个TCP报文除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。
   一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。

9、客户端 （TCP协议进行Socket编程在Python中）
   创建一个基于TCP连接的Socket，可以这样做：
        # 导入socket库:
        import socket
        # 创建一个socket:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 建立连接:
        s.connect(('www.sina.com.cn', 80))
  创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议。客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。
  新浪网站的IP地址可以用域名www.sina.com.cn自动转换到IP地址，80端口是Web服务的标准端口。
  建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容：
        # 发送数据:
        s.send(b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n')
  发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了：
        # 接收数据:
        buffer = []
        while True:
            # 每次最多接收1k字节:
            d = s.recv(1024)
            if d:
                buffer.append(d)
            else:
                break
        data = b''.join(buffer)
  接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。
  当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了：
        # 关闭连接:
        s.close()
   接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件：
        header, html = data.split(b'\r\n\r\n', 1)
        print(header.decode('utf-8'))
        # 把接收的数据写入文件:
        with open('sina.html', 'wb') as f:
            f.write(html)
  现在，只需要在浏览器中打开这个sina.html文件，就可以看到新浪的首页了。

10、服务器 （TCP协议进行Socket编程在Python中）
     创建一个基于IPv4和TCP协议的Socket：
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    我们要绑定监听的地址和端口，127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。
    端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。请注意，小于1024的端口号必须要有管理员权限才能绑定：
        # 监听端口:
        s.bind(('127.0.0.1', 9999))
    紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量：
        s.listen(5)
        print('Waiting for connection...')
    服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接:
        while True:
            # 接受一个新连接:
            sock, addr = s.accept()
            # 创建新线程来处理TCP连接:
            t = threading.Thread(target=tcplink, args=(sock, addr))
            t.start()
    每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接：
    连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上Hello再发送给客户端。如果客户端发送了exit字符串，就直接关闭连接。
        def tcplink(sock, addr):
            print('Accept new connection from %s:%s...' % addr)
            sock.send(b'Welcome!')
            while True:
                data = sock.recv(1024)
                time.sleep(1)
                if not data or data.decode('utf-8') == 'exit':
                    break
                sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8'))
            sock.close()
            print('Connection from %s:%s closed.' % addr)
    要测试这个服务器程序，我们还需要编写一个客户端程序：
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 建立连接:
        s.connect(('127.0.0.1', 9999))
        # 接收欢迎消息:
        print(s.recv(1024).decode('utf-8'))
        for data in [b'Michael', b'Tracy', b'Sarah']:
            # 发送数据:
            s.send(data)
            print(s.recv(1024).decode('utf-8'))
        s.send(b'exit')
        s.close()
    需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。
    同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。
    
11、TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。
    使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。
    虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。

12、以太网、Zigbee、Bluetooth、wifi与七层协议
    以太网（Ethernet）：是一种计算机局域网技术。包括物理层的连线、电子信号和介质访问层协议的内容。属于有线局域网在OSI数据链路层和物理层的，支持TCP/IP。

    Zigbee、Bluetooth、wifi：三种最常用无线通信协议，在无线2.4GHZ频段内，均属于无线局域网在OSI数据链路层和物理层的。可以随时架设，数十分钟内组建起通信链路。
    从传输距离，WIFI>ZigBee>蓝牙;从功耗，是WIFI>蓝牙>ZigBee，后两者仅靠电池供电即可;从传输速率，是WIFI>ZigBee>蓝牙。
    WiFi是以太网的一种无线扩展，定义了介质访问接入控制层(MAC层)和物理层。
    物联设备分为两类，一类是其自身天然支持TCP/IP而能直接接入物联网，如wifi、GPRS/3G/4G/5G等设备；
    另一类是其未能支持IP协议而需要网关（协议转换）来接入物联网，如Zigbee、蓝牙等设备。对于蓝牙设备而言，手机其实是一个网关。
    手机通过自身的蓝牙跟外设蓝牙设备通信，并将消息通过手机的wifi或者3G/4G模块与云服务端通信。
    物联网核心组成就是：设备端—设备网关—云端服务器—手机。
    和Wifi类似，蓝牙也是通过一颗控制芯片和相应的驱动软件控制的通信标准，内置在手机里面。Zigbee、Bluetooth、wifi既要硬件支持又要软件支持。

    OSI（开放式系统互联）七层网络通信协议模型：这个模型把网络通信的工作分为7层,分别是物理层,数据链路层,网络层,传输层,会话层,表示层和应用层。1至4层被认为是低层，
    这些层与数据移动密切相关。5至7层是高层，包含应用程序级的数据。每一层负责一项具体的工作，然后把数据传送到下一层。
    七层网络通信协议是以软件驱动程序的形式被装载到计算机中的。协议栈的每一层都定义一些特定的功能。当最高层的应用程序需要发送消息到网络上的其它系统时，
    这个应用程序就和下面的层进行交互。这个请求是在一个层进行包装，并向下传送到下一个层的它将增加一些和这个层处理功能相应的信息，
    在一个分组内产生一个新的分组。然后，这个分组被向下传递到下一个层，并且这个过程将继续。每个层都向这个消息分组增加信息，
    并且这个信息将被接收系统的协议栈的相应层进行读取。按照这个方式，每个协议层与它对应的协议层进行通信以完成通信。
    七层网络协议：
        物理层：在进行任何通信层的工作之前，你必须安装了网络硬件——物理层，物理层定义接口的物理特性。关心的是接口，信号，和介质，只是说明标准，如以太网。（硬件接口的物理特性）
        数据链路层：数据链路层定义在两个系统的物理连接之间发送和接收信息的规则。这一层为进行传输，对数据进行编码和编帧，另外还提供出错检测和控制。(硬件接口物理特性访问方式，主要是驱动程序)
            一类是局域网中数据连路层协议：MAC子层协议，有LLC子层协议．另一类是广域网的协议如：HDLC，PPP，SLIP。
            数据链路层的通用协议：LAN(有线局域网)、WLAN(无线局域网)驱动程序和访问方式，例如以太网(局域网)、蓝牙(无线局域网)、WiFi(无线局域网)、 ZigBee(无线局域网)的驱动程序都在这层。主要是驱动程序，固件等。
            数据链路层分为上层LLC（Logical Links Control，逻辑链路控制），和下层的MAC（媒体访问控制），MAC主要负责控制与连接物理层的物理介质，定义了数据包怎样在介质上进行传输。
            在发送数据的时候，MAC协议可以事先判断是否可以发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层；
            在接收数据的时候，MAC协议首先判断输入的信息并是否发生传输错误，如果没有错误，则去掉控制信息发送至LLC（逻辑链路控制）层。
        网络层：网络层定义为在系统之间开辟和维护网络路径的协议，主要是IP协议。(开辟和维护网络路径)
        传输层：主要是面向连接的TCP传输控制协议，另一个是不面向连接的UDP用户数据报协议。通过在两个端系统间提供面向连接的服务，提供了高质量的服务和准确的传递。
        会话层：主要是解决一个会话的开始进行和结束。通过使用会话技术或对话，协调系统间的信息交换。
        表示层：主要是编码，如ASⅡ。为了显示或打印信息，在这一层对信息格式化。数据内的代码将被解释。在这一层还进行数据加密和其它字符集的翻译。
        应用层：就是应用程序里面的，文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。 


    利用TCP/IP协议族进行通信的时候，有三个比较关键的确认身份的信息：mac地址、IP地址和端口号。

    mac地址是在数据链路层包裹在以太网头部中的，它主要用来识别同一个链路中的不同计算机。Mac地址即网卡号，每块网卡出厂的时候，都有一个全世界独一无二的 MAC 地址，长度是 48 个二进制位，通常用 12 个十六进制数表示。
    IP地址是在网络层的IP头部里，用于识别网络中互联的主机和路由器，其实主要是确认子网，通过子网掩码确认某个IP地址所在的子网，而后再在子网内部确认mac地址就能找到准确的用户了。
    端口号是在传输层包含在TCP/UDP头部中的，用于识别应用程序。一台主机上能运行多个程序，那么接收到的消息到底是哪个程序的呢？就需要端口号来确认。
    端口号有两种：

    固定的端口号，是形如http,telnet,ftp等广为使用的应用协议所使用的端口号是固定的
    动态分配的端口号，这个时候服务端要确定监听端口号，接受服务的客户端没必要确定端口号

13、局域网的理解：什么是互联网，互联网就是由一个个局域网组成，局域网内的计算机不管是对内还是对外都是靠吼，这就是数据链路层的工作方式-----广播。
    广播出去以后，所有人都听得见，所有人都会拆开这个包，读发送者是谁，接收者是谁，只要接收者不是自己就丢弃掉。
    计算机底层，一个局域网内，都是靠广播的方式，靠吼。
    网络层的ip帮区分子网，以太网层的mac帮找到主机。
    传输层建立端口到端口的通信。补充：端口范围0-65535，0-1023为系统占用端口。

14、客户机发起一次请求与回复的全过程：
    客户机会将请求封装成http数据包-->封装成Tcp数据包-->封装成Ip数据包--->封装成数据帧
     --->硬件将帧数据转换成bit流（二进制数据）-->最后通过物理硬件（网卡芯片）发送到指定地点。
    服务器硬件首先收到bit流，将bit流转换成帧数据，然后再转换成ip数据包。于是通过ip协议解析Ip数据包，然后又发现里面是tcp数据包，
    就通过tcp协议解析Tcp数据包，接着发现是http数据包，通过http协议再解析http数据包得到数据。
    
